{"ast":null,"code":"import _regeneratorRuntime from \"/Users/adotmob/Desktop/bikerace/node_modules/@babel/runtime/regenerator\";\nimport _objectSpread from \"/Users/adotmob/Desktop/bikerace/node_modules/@babel/runtime/helpers/esm/objectSpread\";\nimport _asyncToGenerator from \"/Users/adotmob/Desktop/bikerace/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";\nimport axios from \"axios\";\nimport Filter from \"bad-words\";\nimport striptags from \"striptags\";\nvar filter = new Filter();\nvar API_URL = \"https://api.flickr.com/services/rest/\";\nvar DEFAULT_PARAMS = {\n  api_key: \"fbb18c11c83de0d21ee27d456e828586\",\n  safe_search: 1,\n  per_page: 40,\n  format: \"json\",\n  nojsoncallback: 1,\n  extras: \"owner_name,description,tags\"\n};\n\nif (!process.env.REACT_APP_FLICKR_API_KEY) {\n  console.error(\"No Flickr API key found. Please refer to documentation.\");\n}\n/**\n * Returns Flickr photo URL based on the photo's ID and CDN attributes.\n * @param {Object} photo Flickr photo object\n * @return String Photo URL\n */\n\n\nfunction getPhotoURL(photo) {\n  var id = photo.id,\n      farm = photo.farm,\n      secret = photo.secret,\n      server = photo.server;\n  return \"https://farm\".concat(farm, \".staticflickr.com/\").concat(server, \"/\").concat(id, \"_\").concat(secret, \".jpg\");\n}\n/**\n * Returns Flickr photo URL for the author, based on the photo's ID and CDN attributes.\n * @param {Object} photo Flickr photo object\n * @return String Author URL\n */\n\n\nfunction getAuthorURL(photo) {\n  return \"https://www.flickr.com/people/\".concat(photo.owner, \"/\");\n}\n/**\n * Returns latest photos from public Flickr feed.\n * @param {string} [tags] Tags to filter by.\n * @return Promise\n */\n\n\nexport function fetchPhotos(_x) {\n  return _fetchPhotos.apply(this, arguments);\n}\n\nfunction _fetchPhotos() {\n  _fetchPhotos = _asyncToGenerator(\n  /*#__PURE__*/\n  _regeneratorRuntime.mark(function _callee(page) {\n    var params, response, photo, photos;\n    return _regeneratorRuntime.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            // Search does not support parameterless searching, in which case we fall back to getRecent.\n            params = _objectSpread({}, DEFAULT_PARAMS, {\n              method: \"flickr.photos.search\",\n              page: page,\n              tags: \",bikerace\"\n            });\n            _context.prev = 1;\n            _context.next = 4;\n            return axios.get(API_URL, {\n              params: params\n            });\n\n          case 4:\n            response = _context.sent;\n            photo = response.data.photos.photo;\n            photos = photo || [];\n            return _context.abrupt(\"return\", photos.filter(function (item) {\n              return !filter.isProfane(item.title);\n            }).map(function (item) {\n              item.description._content = striptags(item.description._content);\n              item.photoURL = getPhotoURL(item);\n              item.authorURL = getAuthorURL(item);\n              return item;\n            }));\n\n          case 10:\n            _context.prev = 10;\n            _context.t0 = _context[\"catch\"](1);\n            new Error(\"Flickr request failed.\");\n\n          case 13:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee, null, [[1, 10]]);\n  }));\n  return _fetchPhotos.apply(this, arguments);\n}\n\nexport default {\n  fetchPhotos: fetchPhotos\n};","map":{"version":3,"sources":["/Users/adotmob/Desktop/bikerace/src/api/api.js"],"names":["axios","Filter","striptags","filter","API_URL","DEFAULT_PARAMS","api_key","safe_search","per_page","format","nojsoncallback","extras","process","env","REACT_APP_FLICKR_API_KEY","console","error","getPhotoURL","photo","id","farm","secret","server","getAuthorURL","owner","fetchPhotos","page","params","method","tags","get","response","data","photos","item","isProfane","title","map","description","_content","photoURL","authorURL","Error"],"mappings":";;;AAAA,OAAOA,KAAP,MAAkB,OAAlB;AACA,OAAOC,MAAP,MAAmB,WAAnB;AACA,OAAOC,SAAP,MAAsB,WAAtB;AAEA,IAAMC,MAAM,GAAG,IAAIF,MAAJ,EAAf;AACA,IAAMG,OAAO,GAAG,uCAAhB;AAEA,IAAMC,cAAc,GAAG;AACrBC,EAAAA,OAAO,EAAE,kCADY;AAErBC,EAAAA,WAAW,EAAE,CAFQ;AAGrBC,EAAAA,QAAQ,EAAE,EAHW;AAIrBC,EAAAA,MAAM,EAAE,MAJa;AAKrBC,EAAAA,cAAc,EAAE,CALK;AAMrBC,EAAAA,MAAM,EAAE;AANa,CAAvB;;AASA,IAAI,CAACC,OAAO,CAACC,GAAR,CAAYC,wBAAjB,EAA2C;AACzCC,EAAAA,OAAO,CAACC,KAAR,CAAc,yDAAd;AACD;AAED;;;;;;;AAKA,SAASC,WAAT,CAAqBC,KAArB,EAA4B;AAAA,MAClBC,EADkB,GACWD,KADX,CAClBC,EADkB;AAAA,MACdC,IADc,GACWF,KADX,CACdE,IADc;AAAA,MACRC,MADQ,GACWH,KADX,CACRG,MADQ;AAAA,MACAC,MADA,GACWJ,KADX,CACAI,MADA;AAG1B,+BAAsBF,IAAtB,+BAA+CE,MAA/C,cAAyDH,EAAzD,cAA+DE,MAA/D;AACD;AAED;;;;;;;AAKA,SAASE,YAAT,CAAsBL,KAAtB,EAA6B;AAC3B,iDAAwCA,KAAK,CAACM,KAA9C;AACD;AAED;;;;;;;AAKA,gBAAsBC,WAAtB;AAAA;AAAA;;;;;2BAAO,iBAA2BC,IAA3B;AAAA;AAAA;AAAA;AAAA;AAAA;AACL;AACMC,YAAAA,MAFD,qBAGAtB,cAHA;AAIHuB,cAAAA,MAAM,EAAE,sBAJL;AAKHF,cAAAA,IAAI,EAAJA,IALG;AAMHG,cAAAA,IAAI,EAAE;AANH;AAAA;AAAA;AAAA,mBAUoB7B,KAAK,CAAC8B,GAAN,CAAU1B,OAAV,EAAmB;AAAEuB,cAAAA,MAAM,EAANA;AAAF,aAAnB,CAVpB;;AAAA;AAUGI,YAAAA,QAVH;AAWKb,YAAAA,KAXL,GAWea,QAAQ,CAACC,IAAT,CAAcC,MAX7B,CAWKf,KAXL;AAYGe,YAAAA,MAZH,GAYYf,KAAK,IAAI,EAZrB;AAAA,6CAaIe,MAAM,CAAC9B,MAAP,CAAc,UAAA+B,IAAI;AAAA,qBAAI,CAAC/B,MAAM,CAACgC,SAAP,CAAiBD,IAAI,CAACE,KAAtB,CAAL;AAAA,aAAlB,EACNC,GADM,CACF,UAAAH,IAAI,EAAI;AACXA,cAAAA,IAAI,CAACI,WAAL,CAAiBC,QAAjB,GAA4BrC,SAAS,CAACgC,IAAI,CAACI,WAAL,CAAiBC,QAAlB,CAArC;AACEL,cAAAA,IAAI,CAACM,QAAL,GAAgBvB,WAAW,CAACiB,IAAD,CAA3B;AACAA,cAAAA,IAAI,CAACO,SAAL,GAAiBlB,YAAY,CAACW,IAAD,CAA7B;AACA,qBAAOA,IAAP;AACH,aANM,CAbJ;;AAAA;AAAA;AAAA;AAqBH,gBAAIQ,KAAJ,CAAU,wBAAV;;AArBG;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,G;;;;AA+CP,eAAe;AACbjB,EAAAA,WAAW,EAAXA;AADa,CAAf","sourcesContent":["import axios from \"axios\";\nimport Filter from \"bad-words\";\nimport striptags from \"striptags\";\n\nconst filter = new Filter();\nconst API_URL = \"https://api.flickr.com/services/rest/\";\n\nconst DEFAULT_PARAMS = {\n  api_key: \"fbb18c11c83de0d21ee27d456e828586\",\n  safe_search: 1,\n  per_page: 40,\n  format: \"json\",\n  nojsoncallback: 1,\n  extras: \"owner_name,description,tags\"\n};\n\nif (!process.env.REACT_APP_FLICKR_API_KEY) {\n  console.error(\"No Flickr API key found. Please refer to documentation.\");\n}\n\n/**\n * Returns Flickr photo URL based on the photo's ID and CDN attributes.\n * @param {Object} photo Flickr photo object\n * @return String Photo URL\n */\nfunction getPhotoURL(photo) {\n  const { id, farm, secret, server } = photo;\n\n  return `https://farm${farm}.staticflickr.com/${server}/${id}_${secret}.jpg`;\n}\n\n/**\n * Returns Flickr photo URL for the author, based on the photo's ID and CDN attributes.\n * @param {Object} photo Flickr photo object\n * @return String Author URL\n */\nfunction getAuthorURL(photo) {\n  return `https://www.flickr.com/people/${photo.owner}/`;\n}\n\n/**\n * Returns latest photos from public Flickr feed.\n * @param {string} [tags] Tags to filter by.\n * @return Promise\n */\nexport async function fetchPhotos(page) {\n  // Search does not support parameterless searching, in which case we fall back to getRecent.\n  const params = {\n    ...DEFAULT_PARAMS,\n    method: \"flickr.photos.search\",\n    page,\n    tags: \",bikerace\"\n  };\n\n  try {\n    const response = await axios.get(API_URL, { params });\n    const { photo } = response.data.photos;\n    const photos = photo || [];\n    return photos.filter(item => !filter.isProfane(item.title))\n    .map(item => {\n      item.description._content = striptags(item.description._content);\n        item.photoURL = getPhotoURL(item);\n        item.authorURL = getAuthorURL(item);\n        return item;\n    });\n  } catch (error) {\n    new Error(\"Flickr request failed.\");\n  }\n  // return axios.get(API_URL, { params }).then(({ data }) => {\n  //   if (process.env.NODE_ENV === \"development\") {\n  //     console.log(\"Fetched photos \", data);\n  //   }\n\n  //   if (data.stat === \"fail\" || !data.photos) {\n  //     throw new Error(\"Flickr request failed.\");\n  //   }\n\n  //   const photos = data.photos.photo || [];\n\n  //   // In this demo we're filtering out photos that _might_ be NSFW. The \"safe\" flag is\n  //   // set by the user and not entirely reliable.\n  //   return photos\n  //     .filter(item => !filter.isProfane(item.title))\n  //     .map(item => {\n  //       item.description._content = striptags(item.description._content);\n  //       item.photoURL = getPhotoURL(item);\n  //       item.authorURL = getAuthorURL(item);\n  //       return item;\n  //     });\n  // });\n}\n\nexport default {\n  fetchPhotos\n};\n"]},"metadata":{},"sourceType":"module"}