{"ast":null,"code":"import _objectSpread from \"/Users/adotmob/Desktop/bikerace/node_modules/@babel/runtime/helpers/esm/objectSpread\";\nimport _regeneratorRuntime from \"/Users/adotmob/Desktop/bikerace/node_modules/@babel/runtime/regenerator\";\nimport _asyncToGenerator from \"/Users/adotmob/Desktop/bikerace/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";\nimport axios from \"axios\";\nimport Filter from \"bad-words\";\nimport striptags from \"striptags\";\nvar filter = new Filter();\nvar API_URL = \"https://api.flickr.com/services/rest/\";\nvar DEFAULT_PARAMS = {\n  api_key: \"fbb18c11c83de0d21ee27d456e828586\",\n  safe_search: 1,\n  per_page: 40,\n  format: \"json\",\n  nojsoncallback: 1,\n  extras: \"owner_name,description,tags\"\n};\n\nif (!process.env.REACT_APP_FLICKR_API_KEY) {\n  console.error(\"No Flickr API key found. Please refer to documentation.\");\n}\n/**\n * Returns Flickr photo URL based on the photo's ID and CDN attributes.\n * @param {Object} photo Flickr photo object\n * @return String Photo URL\n */\n\n\nfunction getPhotoURL(photo) {\n  var id = photo.id,\n      farm = photo.farm,\n      secret = photo.secret,\n      server = photo.server;\n  return \"https://farm\".concat(farm, \".staticflickr.com/\").concat(server, \"/\").concat(id, \"_\").concat(secret, \".jpg\");\n}\n/**\n * Returns Flickr photo URL for the author, based on the photo's ID and CDN attributes.\n * @param {Object} photo Flickr photo object\n * @return String Author URL\n */\n\n\nfunction getAuthorURL(photo) {\n  return \"https://www.flickr.com/people/\".concat(photo.owner, \"/\");\n}\n/**\n * Returns latest photos from public Flickr feed.\n * @param {string} [tags] Tags to filter by.\n * @return Promise\n */\n\n\nexport function fetchPhotos(_x) {\n  return _fetchPhotos.apply(this, arguments);\n}\n\nfunction _fetchPhotos() {\n  _fetchPhotos = _asyncToGenerator(\n  /*#__PURE__*/\n  _regeneratorRuntime.mark(function _callee2(page) {\n    var params, response, photo, photos;\n    return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n      while (1) {\n        switch (_context2.prev = _context2.next) {\n          case 0:\n            // Search does not support parameterless searching, in which case we fall back to getRecent.\n            params = _objectSpread({}, DEFAULT_PARAMS, {\n              method: \"flickr.photos.search\",\n              page: page,\n              tags: \",bikerace\"\n            });\n            _context2.prev = 1;\n            _context2.next = 4;\n            return axios.get(API_URL, {\n              params: params\n            });\n\n          case 4:\n            response = _context2.sent;\n            photo = response.data.photos.photo;\n            photos = photo || [];\n            return _context2.abrupt(\"return\", photos.filter(function (item) {\n              return !filter.isProfane(item.title) && item.farm !== 0;\n            }).map(function (item) {\n              item.description._content = striptags(item.description._content);\n              item.photoURL = getPhotoURL(item);\n              item.authorURL = getAuthorURL(item);\n              return item;\n            }));\n\n          case 10:\n            _context2.prev = 10;\n            _context2.t0 = _context2[\"catch\"](1);\n            new Error(\"Flickr request failed.\");\n\n          case 13:\n          case \"end\":\n            return _context2.stop();\n        }\n      }\n    }, _callee2, null, [[1, 10]]);\n  }));\n  return _fetchPhotos.apply(this, arguments);\n}\n\nexport var fetchRiders = function fetchRiders() {\n  return (\n    /*#__PURE__*/\n    function () {\n      var _ref = _asyncToGenerator(\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee(dispatch) {\n        var res, response;\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                _context.prev = 0;\n                _context.next = 3;\n                return axios.get(\"\".concat(API_URL, \"/riders\"));\n\n              case 3:\n                res = _context.sent;\n\n                if (res.status === 200) {\n                  dispatch({\n                    type: FETCH_RIDERS,\n                    riders: res.data\n                  });\n                }\n\n                _context.next = 11;\n                break;\n\n              case 7:\n                _context.prev = 7;\n                _context.t0 = _context[\"catch\"](0);\n                response = _context.t0.response;\n                dispatch({\n                  type: ERROR_RIDERS\n                });\n\n              case 11:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, null, [[0, 7]]);\n      }));\n\n      return function (_x2) {\n        return _ref.apply(this, arguments);\n      };\n    }()\n  );\n};\nexport default {\n  fetchPhotos: fetchPhotos\n};","map":{"version":3,"sources":["/Users/adotmob/Desktop/bikerace/src/api/api.js"],"names":["axios","Filter","striptags","filter","API_URL","DEFAULT_PARAMS","api_key","safe_search","per_page","format","nojsoncallback","extras","process","env","REACT_APP_FLICKR_API_KEY","console","error","getPhotoURL","photo","id","farm","secret","server","getAuthorURL","owner","fetchPhotos","page","params","method","tags","get","response","data","photos","item","isProfane","title","map","description","_content","photoURL","authorURL","Error","fetchRiders","dispatch","res","status","type","FETCH_RIDERS","riders","ERROR_RIDERS"],"mappings":"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","sourcesContent":["import axios from \"axios\";\nimport Filter from \"bad-words\";\nimport striptags from \"striptags\";\n\nconst filter = new Filter();\nconst API_URL = \"https://api.flickr.com/services/rest/\";\n\nconst DEFAULT_PARAMS = {\n  api_key: \"fbb18c11c83de0d21ee27d456e828586\",\n  safe_search: 1,\n  per_page: 40,\n  format: \"json\",\n  nojsoncallback: 1,\n  extras: \"owner_name,description,tags\"\n};\n\nif (!process.env.REACT_APP_FLICKR_API_KEY) {\n  console.error(\"No Flickr API key found. Please refer to documentation.\");\n}\n\n/**\n * Returns Flickr photo URL based on the photo's ID and CDN attributes.\n * @param {Object} photo Flickr photo object\n * @return String Photo URL\n */\nfunction getPhotoURL(photo) {\n  const { id, farm, secret, server } = photo;\n\n  return `https://farm${farm}.staticflickr.com/${server}/${id}_${secret}.jpg`;\n}\n\n/**\n * Returns Flickr photo URL for the author, based on the photo's ID and CDN attributes.\n * @param {Object} photo Flickr photo object\n * @return String Author URL\n */\nfunction getAuthorURL(photo) {\n  return `https://www.flickr.com/people/${photo.owner}/`;\n}\n\n/**\n * Returns latest photos from public Flickr feed.\n * @param {string} [tags] Tags to filter by.\n * @return Promise\n */\nexport async function fetchPhotos(page) {\n  // Search does not support parameterless searching, in which case we fall back to getRecent.\n  const params = {\n    ...DEFAULT_PARAMS,\n    method: \"flickr.photos.search\",\n    page,\n    tags: \",bikerace\"\n  };\n\n  try {\n    const response = await axios.get(API_URL, { params });\n    const { photo } = response.data.photos;\n    const photos = photo || [];\n    return photos\n      .filter(item => !filter.isProfane(item.title) && item.farm !== 0)\n      .map(item => {\n        item.description._content = striptags(item.description._content);\n        item.photoURL = getPhotoURL(item);\n        item.authorURL = getAuthorURL(item);\n        return item;\n      });\n  } catch (error) {\n    new Error(\"Flickr request failed.\");\n  }\n}\n\n\nexport const fetchRiders = () => async dispatch => {\n  try {\n    const res = await axios.get(`${API_URL}/riders`);\n    if (res.status === 200) {\n      dispatch({ type: FETCH_RIDERS, riders: res.data });\n    }\n  } catch ({ response }) {\n    dispatch({ type: ERROR_RIDERS });\n  }\n};\n\n\nexport default {\n  fetchPhotos\n};\n\n"]},"metadata":{},"sourceType":"module"}